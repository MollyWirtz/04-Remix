<!DOCTYPE html>
<html>
    <head>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script src="https://d3js.org/d3-color.v2.min.js"></script>
        <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
        <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
    </head>
    <body>
        <div id="brush_vis"></div>
        <div id="line_vis"></div>
        <div id="bar_vis"></div>
    </body>

    <script>
        /******* REMIXED VIS *******/
        var brushHeight = 100
        var brushWidth = 600
        var brushMargin = ({top: 20, right: 20, bottom: 20, left: 20})
        var zoomed = false
        var formerSelect = []

        
        // Append SVG
        var brushSvg = d3.select("#brush_vis")
            .append("svg")
                .attr("width", brushWidth + brushMargin.left + brushMargin.right)
                .attr("height", brushHeight + brushMargin.top + brushMargin.bottom)
            .append("g")
                .attr("transform", "translate(" + brushMargin.left + "," + brushMargin.top + ")");
        

        // Create data
        var data = []
        for (let i = 0 ; i < 100 ; i++){
            data.push({x: Math.random() * (0.98 - 0.02) + 0.02, y: Math.random() * (8 - 0.5) + 0.5})
        }
        for (let i = 0 ; i < 100 ; i++){
            data.push({x: Math.random() * (0.95 - 0.15) + 0.15, y: Math.random() * (6.5 - 3) + 3})
        }
        for (let i = 0 ; i < 500 ; i++){
            data.push({x: Math.random() * (0.9 - 0.1) + 0.1, y: Math.random() * (6 - 2.5) + 2.5})
        }


        // Create axes
        var x = d3.scaleLinear()
            .domain([0, 1])
            .range([ 0, brushWidth ]);

        var xAxis = brushSvg.append("g")
            .attr("transform", "translate(0," + brushHeight + ")")
            .call(d3.axisBottom(x));

        var y = d3.scaleLinear()
            .domain([0, 9])
            .range([ brushHeight, 0]);


        // Add a clipPath to avoid drawing anything outside that area
        var clip = brushSvg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", brushWidth )
            .attr("height", brushHeight )
            .attr("x", 0)
            .attr("y", 0)
        

        // Add brush
        var brush = d3.brushX()                 
            .extent( [ [0,0], [brushWidth, brushHeight] ] ) 


        // Create the scatter variable: where both the circles and the brush take place
        var scatter = brushSvg.append('g')
            .attr("clip-path", "url(#clip)")
            .attr("id", scatter);
        

        // Add circles
        scatter
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )
                .attr("r", 3.5)
                .attr("stroke", d => "black" )
                .attr("stroke-width", 0.5)
                .attr("fill", function (d) { return d3.interpolateSpectral(d.x) })
                .attr("fill-opacity", d => 0.8)
                .style("opacity", 0.5);


        // Add the brushing
        scatter.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, [0.3, 0.5].map(x));
        

        // A function that update the chart for given boundaries
        function updateChart(selection) {  
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if(!selection){
                x.domain([0,1])
                scatter.select(".brush").call(brush.move, formerSelect)
            } else {
                x.domain([ x.invert(selection[0]), x.invert(selection[1]) ])
                formerSelect = [selection[0], selection[1]]
                scatter.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and circle position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            scatter
                .selectAll("circle")
                .transition().duration(1000)
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )

            if (zoomed) zoomed = false;
            else zoomed = true;  
            
            var filteredLineData = []
            var filteredBarData = []
            var counter = 0 

            if (zoomed) {
                d3.selectAll("circle").each( function(d, i){
                    let cx = d3.select(this).attr("cx");
                    if (cx >= formerSelect[0] && cx <= formerSelect[1]){
                        counter += 1;
                        filteredLineData.push([
                            x.invert(d3.select(this).attr("cx")), 
                            y.invert(d3.select(this).attr("cy"))
                        ])
                        filteredBarData.push([
                            counter.toString(), 
                            y.invert(d3.select(this).attr("cy")), 
                            d3.select(this).attr("fill")
                        ])
                    }
                })
                updateBarChart(filteredBarData, x.domain())
            } 
            // updateLineChart(filteredLineData, x.domain())
            
        }

        var select = d3.selectAll(".selection")
        scatter
        .on("dblclick", function() { 
            var selection = [select.node().getBBox().x, select.node().getBBox().x + select.node().getBBox().width]
            // Double click to zoom out
            if (zoomed) {
                updateChart()
            }
            //  Double click to zoom
            else {
                formerSelect = selection
                updateChart(selection)
            }
        });


        /***************************/


        /******* SECOND VIEW *******/
        var lineMargin = {top: 20, right: 20, bottom: 20, left: 20}
        var lineWidth = 600 
        var lineHeight = 200 

        var lineSvg = d3.select("#line_vis")
            .append("svg")
            .attr("width", lineWidth + lineMargin.right + lineMargin.left)
            .attr("height", lineHeight + lineMargin.top + lineMargin.bottom)
            .append("g")
            .attr("transform", "translate(" + lineMargin.left + ", " + lineMargin.top +")")

        lineSvg.append("rect")
            .attr("width", lineWidth)
            .attr("height", lineHeight)
            .attr("fill", "#ececec")

        var lineX = d3.scaleLinear().domain([0, 1]).range([0, lineWidth])  
        var lineY = d3.scaleLinear().domain([0, 9]).range([lineHeight, 0])

        var lineXAxis = lineSvg.append("g")
            .attr("transform", "translate(0, "+ lineHeight + ")")
            .call(d3.axisBottom(lineX))

        lineSvg.append("g")
            .call(d3.axisLeft(lineY))


        function updateLineChart(filteredLineData, newDomain) {
            // console.log([Math.min(...test), Math.max(...test)])
            var h = []

            lineSvg.selectAll("dot")
                .data(filteredLineData)
                .enter()
                .append("circle")
                .attr("cx", function (d) { h.push(d[0]); return lineX(d[0]) })
                .attr("cy", function (d) { return lineY(d[1]) })
                .attr("r", 5 )
                .style("fill", "#69b3a2")

            console.log([Math.min(...h), Math.max(...h)])
            
            lineX.domain(newDomain)
            lineXAxis.transition().duration(1000).call(d3.axisBottom(lineX))


            lineSvg.selectAll("circle")
                .transition().duration(1000)
                .attr("cx", function (d) { return lineX(d[0]) })
                .attr("cy", function (d) { return lineY(d[1]) })

        }




        var barMargin = {top: 20, right: 20, bottom: 20, left: 20}
        var barWidth = 600 
        var barHeight = 200 
        var previousData = []

        var barSvg = d3.select("#bar_vis")
            .append("svg")
            .attr("width", barWidth + barMargin.right + barMargin.left)
            .attr("height", barHeight + barMargin.top + barMargin.bottom)
            .append("g")
            .attr("transform", "translate(" + barMargin.left + ", " + barMargin.top +")")

        barSvg.append("rect")
            .attr("width", barWidth)
            .attr("height", barHeight)
            .attr("fill", "#ececec")




        function updateBarChart(filteredBarData, newDomain) {

            d3.selectAll('#barContent').remove();

            // var sortedData = filteredBarData.slice().sort((a,b) => d3.ascending(a[2], b[2]))
            
            var barX = d3.scaleBand()
                .domain(d3.range(filteredBarData.length))
                .range([0, barWidth])
            var barY = d3.scaleLinear().domain([0, 9]).range([barHeight, 0])

            var barXAxis = barSvg.append("g")
                .attr("transform", "translate(0, "+ barHeight + ")")
                .call(d3.axisBottom(barX).tickFormat("").tickSize(0))

            barSvg.append("g")
                .call(d3.axisLeft(barY))

            barSvg.selectAll("bar")
                .data(filteredBarData)
                .enter()
                .append("rect")
                .attr("id", "barContent")
                .attr("x", function (d) { return barX(d[0]) })
                .attr("y", function (d) { return barY(d[1]) })
                .attr("width", barX.bandwidth())
                .attr("height", function(d) { return barHeight - barY(d[1]) })
                .style("fill", function (d) { return d[2] })

            // var group = d3.selectAll("#barContent")
            // group.sort(function (a,b) {
            //     console.log("heelooo")
            //     return d3.ascending(a, b);
            // })
            // .transition()
			// .delay(function(d, i) {
			// 	return i * 50;  // gives it a smoother effect
			// })
			// .duration(1000)
			// .attr("transform", function(d, i) {
			//   	return "translate(" + barX(i) + ",0)";
			// });
            
            previousData = filteredBarData

        }

        
        </script>
</html>