<!DOCTYPE html>
<html>
    <head>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script src="https://d3js.org/d3-color.v2.min.js"></script>
        <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
        <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
    </head>
    <body>
        <div id="brush_vis"></div>
        <div id="bar_vis"></div>
    </body>

    <script>
        /******* REMIXED VIS *******/
        var brushHeight = 100
        var brushWidth = 600
        var brushMargin = ({top: 10, right: 20, bottom: 20, left: 20})
        var zoomed = false
        var formerSelect = []

        
        // Append SVG
        var brushSvg = d3.select("#brush_vis")
            .append("svg")
                .attr("width", brushWidth + brushMargin.left + brushMargin.right)
                .attr("height", brushHeight + brushMargin.top + brushMargin.bottom)
            .append("g")
                .attr("transform", "translate(" + brushMargin.left + "," + brushMargin.top + ")");
        

        // Create data
        var data = []
        for (let i = 0 ; i < 100 ; i++){
            data.push({x: Math.random() * (0.98 - 0.02) + 0.02, y: Math.random() * (8 - 0.5) + 0.5})
        }
        for (let i = 0 ; i < 100 ; i++){
            data.push({x: Math.random() * (0.95 - 0.15) + 0.15, y: Math.random() * (6.5 - 3) + 3})
        }
        for (let i = 0 ; i < 500 ; i++){
            data.push({x: Math.random() * (0.9 - 0.1) + 0.1, y: Math.random() * (6 - 2.5) + 2.5})
        }


        // Create axes
        var x = d3.scaleLinear()
            .domain([0, 1])
            .range([ 0, brushWidth ]);

        var xAxis = brushSvg.append("g")
            .attr("transform", "translate(0," + brushHeight + ")")
            .call(d3.axisBottom(x));

        var y = d3.scaleLinear()
            .domain([0, 9])
            .range([ brushHeight, 0]);


        // Add a clipPath to avoid drawing anything outside that area
        var clip = brushSvg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", brushWidth )
            .attr("height", brushHeight )
            .attr("x", 0)
            .attr("y", 0)
        

        // Add brush
        var brush = d3.brushX()                 
            .extent( [ [0,0], [brushWidth, brushHeight] ] ) 


        // Create the scatter variable: where both the circles and the brush take place
        var scatter = brushSvg.append('g')
            .attr("clip-path", "url(#clip)")
            .attr("id", scatter);
        

        // Add circles
        scatter
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )
                .attr("r", 3.5)
                .attr("stroke", d => "black" )
                .attr("stroke-width", 0.5)
                .attr("fill", function (d) { return d3.interpolateSpectral(d.x) })
                .attr("fill-opacity", d => 0.8)
                .style("opacity", 0.5);


        // Add the brushing
        scatter.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, [0.3, 0.5].map(x));
        

        // A function that set idleTimeOut to null
        var idleTimeout
        function idled() { idleTimeout = null; }
        

        // A function that update the chart for given boundaries
        function updateChart(selection) {  
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if(!selection){
                x.domain([0,1])
                scatter.select(".brush").call(brush.move, formerSelect)
            } else {
                x.domain([ x.invert(selection[0]), x.invert(selection[1]) ])
                formerSelect = [selection[0], selection[1]]
                scatter.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and circle position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            scatter
                .selectAll("circle")
                .transition().duration(1000)
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )

            if (zoomed) zoomed = false;
            else zoomed = true;  
            
            var barData = scatter.selectAll("circle")
            var filteredBarData = []
            // console.log(barData._groups[0])
            // console.log(barData._groups[0][1])
            // console.log(barData._groups[0][1].getBBox().cx)
            // console.log(barData._groups[0][1].attr("cx");
            // console.log(d3.selectAll(".mynode").attr("cx"));
            var i = 0 
            // console.log(formerSelect)
            d3.selectAll("circle").each( function(d, i){
                let cx = d3.select(this).attr("cx");
                if(cx >= formerSelect[0] && cx <= formerSelect[1]){
                    // console.log( d3.select(this).attr("cx"));
                    // console.log( x(d3.select(this).attr("cx")));
                    // console.log( d3.select(this).attr("cy"));
                    // i = i + 1
                    // console.log("getting " + i + " circles")
                    filteredBarData.push([d3.select(this).attr("cx"), d3.select(this).attr("cy")])
                }
            })

            updateBarChart(filteredBarData)
            
        }

        var select = d3.selectAll(".selection")
        scatter
        .on("dblclick", function() { 
            var selection = [select.node().getBBox().x, select.node().getBBox().x + select.node().getBBox().width]
            // Double click to zoom out
            if (zoomed) {
                updateChart()
            }
            //  Double click to zoom
            else {
                formerSelect = selection
                updateChart(selection)
            }
        });


        /***************************/


        /******* SECOND VIEW *******/
        var barMargin = {top: 20, right: 20, bottom: 50, left: 50}
        var barWidth = 640 - barMargin.right - barMargin.left
        var barHeight = 300 - barMargin.top - barMargin.bottom

        var barSvg = d3.select("#bar_vis")
            .append("svg")
            .attr("width", barWidth + barMargin.right + barMargin.left)
            .attr("height", barHeight + barMargin.top + barMargin.bottom)
            .append("g")
            .attr("transform", "translate(" + barMargin.left + ", " + barMargin.top +")")

        barSvg.append("rect")
            .attr("width", barWidth)
            .attr("height", barHeight)
            .attr("fill", "#ececec")

        var barX = d3.scaleLinear().domain([0, 1]).range([0, barWidth])  
        var barY = d3.scaleLinear().domain([7, 9]).range([barHeight, 0])

        barSvg.append("g")
            .attr("transform", "translate(0, "+ barHeight + ")")
            .call(d3.axisBottom(barX))

        barSvg.append("g")
            .call(d3.axisLeft(barY))

        // var focus = svg.append("g")
        //     .attr("class", "focus")
        //     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // var context = svg.append("g")
        //     .attr("class", "context")
        //     .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
        
        function updateBarChart(filteredBarData) {
            console.log(filteredBarData)

            barSvg.selectAll("dot")
                .data(filteredBarData)
                .enter()
                .append("circle")
                .attr("cx", function (d) { return d[0] })
                .attr("cy", function (d) { return d[1] })
                .attr("r", 5 )
                // .style("height", function(d) { return barHeight - barY(d[1]); })
                .style("fill", "#69b3a2")

        }

        
        </script>
</html>