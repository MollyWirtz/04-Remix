<!DOCTYPE html>
<html>
    <head>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script src="https://d3js.org/d3-color.v2.min.js"></script>
        <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
        <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
    </head>
    <body>
        <div id="dataviz_brushZoom"></div>
    </body>

    <script>
        var height = 100
        var width = 600
        var margin = ({top: 10, right: 20, bottom: 20, left: 20})
        var zoomed = false
        var formerSelect = []

        
        // Append SVG
        var Svg = d3.select("#dataviz_brushZoom")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        

        // Create data
        var data = []
        for (let i = 0 ; i < 100 ; i++){
            data.push({x: Math.random() * (0.9 - 0.1) + 0.1, y: Math.random() * (8 - 1.5) + 1.5})
        }
        for (let i = 0 ; i < 300 ; i++){
            data.push({x: Math.random() * (0.85 - 0.15) + 0.15, y: Math.random() * (7 - 2.5) + 2.5})
        }
        for (let i = 0 ; i < 300 ; i++){
            data.push({x: Math.random() * (0.6 - 0.3) + 0.3, y: Math.random() * (7 - 2.5) + 2.5})
        }


        // Create axes
        var x = d3.scaleLinear()
            .domain([0, 1])
            .range([ 0, width ]);

        var xAxis = Svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

        var y = d3.scaleLinear()
            .domain([0, 9])
            .range([ height, 0]);


        // Brush handles
        arc = d3.arc()
            .innerRadius(0)
            .outerRadius((height - margin.top - margin.bottom) / 2)
            .startAngle(0)
            .endAngle((d, i) => i ? Math.PI : -Math.PI)

        brushHandle = (g, selection) => g
            .selectAll(".handle--custom")
            .data([{type: "w"}, {type: "e"}])
            .join(enter => enter.append("path")
                .attr("class", "handle--custom")
                .attr("fill", "#666")
                .attr("fill-opacity", 0.8)
                .attr("stroke", "#000")
                .attr("stroke-width", 1.5)
                .attr("cursor", "ew-resize")
                .attr("d", arc))
                .attr("display", selection === null ? "none" : null)
                .attr("transform", selection === null ? null : (d, i) => `translate(${selection[i]},${(height + margin.top - margin.bottom) / 2})`)
                .attr("id", "brushHandle")


        // Add a clipPath to avoid drawing anything outside that area
        var clip = Svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width )
            .attr("height", height )
            .attr("x", 0)
            .attr("y", 0)
        

        // Add brush
        var brush = d3.brushX()                 
            .extent( [ [0,0], [width,height] ] ) 


        // Create the scatter variable: where both the circles and the brush take place
        var scatter = Svg.append('g')
            .attr("clip-path", "url(#clip)")
            .attr("id", scatter);
        

        // Add circles
        scatter
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )
                .attr("r", 3.5)
                .attr("stroke", d => "black" )
                .attr("stroke-width", 0.5)
                .attr("fill", function (d) { return d3.interpolateSpectral(d.x) })
                .attr("fill-opacity", d => 0.8)
                .style("opacity", 0.5);


        // Add the brushing
        scatter.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, [0.3, 0.5].map(x));
        

        // A function that set idleTimeOut to null
        var idleTimeout
        function idled() { idleTimeout = null; }
        

        // A function that update the chart for given boundaries
        function updateChart(selection) {  
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if(!selection){
                x.domain([0,1])
                scatter.select(".brush").call(brush.move, formerSelect)
            } else {
                x.domain([ x.invert(selection[0]), x.invert(selection[1]) ])
                formerSelect = [selection[0], selection[1]]
                scatter.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and circle position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            scatter
                .selectAll("circle")
                .transition().duration(1000)
                .attr("cx", function (d) { return x(d.x); } )
                .attr("cy", function (d) { return y(d.y); } )

            if (zoomed) zoomed = false;
            else zoomed = true;        
        }

        var select = d3.selectAll(".selection")
        scatter
        .on("dblclick", function() { 

            var selection = [select.node().getBBox().x, select.node().getBBox().x + select.node().getBBox().width]
            // Double click to zoom out
            if (zoomed) {
                updateChart()
            }
            //  Double click to zoom
            else {
                formerSelect = selection
                updateChart(selection)
            }
        });
        
        </script>
</html>