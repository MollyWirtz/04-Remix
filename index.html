<!DOCTYPE html>
<html>
    <head>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script src="https://d3js.org/d3-color.v2.min.js"></script>
        <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
        <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
    </head>
    <body>
        <svg id="originalVis"></svg>

    </body>

    <script>

        /** Original Vis **/

        // Dimensions
        var height = 100
        var width = 500
        var margin = ({top: 10, right: 20, bottom: 20, left: 20})


        // Axes
        var x = d3.scaleLinear([0, 1], [margin.left, width - margin.right])
        var y = d3.randomNormal(height / 2, height / 12)
        
        xAxis = g => g
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .attr("id", "xAxis")
        .call(d3.axisBottom(x))


                
        var svg = d3.select('#originalVis')
        .attr("viewBox", [0, 0, width, height])

        svg.append("g").call(xAxis);


        // Zoom variables
        var zoomed = false
        var currentPosition = []


        // Brush handles
        arc = d3.arc()
        .innerRadius(0)
        .outerRadius((height - margin.top - margin.bottom) / 2)
        .startAngle(0)
        .endAngle((d, i) => i ? Math.PI : -Math.PI)

        brushHandle = (g, selection) => g
        .selectAll(".handle--custom")
        .data([{type: "w"}, {type: "e"}])
        .join(enter => enter.append("path")
            .attr("class", "handle--custom")
            .attr("fill", "#666")
            .attr("fill-opacity", 0.8)
            .attr("stroke", "#000")
            .attr("stroke-width", 1.5)
            .attr("cursor", "ew-resize")
            .attr("d", arc))
        .attr("display", selection === null ? "none" : null)
        .attr("transform", selection === null ? null : (d, i) => `translate(${selection[i]},${(height + margin.top - margin.bottom) / 2})`)
        .attr("id", "brushHandle")


        // Brush
        const brush = d3.brushX()
        .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]])
        .on("start brush end", brushed);


        // Data
        var circle = svg.append("g")
        .attr("fill-opacity", 0.2)
        .selectAll("circle")
        .data(Float64Array.from({length: 800}, Math.random))
        .join("circle")
        // .attr("transform", d => `translate(${x(d)},${y()})`)
        .attr("transform", function(d) { console.log(x(d), y()); return `translate(${x(d)},${y()})`})
        .attr("r", 3.5);

        var clip = svg.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", width )
        .attr("height", height )
        .attr("x", 0)
        .attr("y", 0)


        // Brush function
        function brushed({selection}) {
            if (selection === null) {
                circle.attr("stroke", null);
            } else {
                const sx = selection.map(x.invert);
                if (!zoomed) {
                    console.log("setting current position at " + [sx[0], sx[1]])
                    currentPosition = [sx[0], sx[1]]
                }
                circle.attr("stroke", function(d) {
                    if (sx[0] <= d && d <= sx[1]) return "black"
                    return null
                });
                circle.attr("stroke-width", 0.5)
                circle.attr("fill", d => sx[0] <= d && d <= sx[1] ? d3.interpolateSpectral(d) : null);
                circle.attr("fill-opacity", d => sx[0] <= d && d <= sx[1] ? 0.8 : null);

                if (zoomed) {
                    circle.attr("stroke", d => "black" );
                    circle.attr("stroke-width", 0.5)
                    circle.attr("fill", d =>  d3.interpolateSpectral(d) );
                    circle.attr("fill-opacity", d => 0.8);
                } else {
                    circle.attr("stroke", d => sx[0] <= d && d <= sx[1] ? "black" : null);
                    circle.attr("stroke-width", 0.5)
                    circle.attr("fill", d => sx[0] <= d && d <= sx[1] ? d3.interpolateSpectral(d) : null);
                    circle.attr("fill-opacity", d => sx[0] <= d && d <= sx[1] ? 0.8 : null);
                }
            }
            d3.select(this).call(brushHandle, selection);
            return svg.node();
        }

        svg.append("g")
        .attr("id", "selectionG")
        .attr("clip-path", "url(#clip)")
        .call(brush)
        .call(brush.move, [0.3, 0.5].map(x));


        // Zoom function
        d3.selectAll("#selectionG")
        .on("dblclick", function() { 
            updateChart()
        });


        // Zoom part 2
        function updateChart() {
            // Zoom in
            if (!zoomed) {
                zoomed = true

                // Change x-axis
                let x1 = d3.selectAll(".selection").node().getBBox().x
                let x2 = x1 + d3.selectAll(".selection").node().getBBox().width
                x.domain([ x.invert(x1), x.invert(x2) ])
                d3.selectAll("#xAxis").transition().duration(1000).call(d3.axisBottom(x))

                // Remove brush handles
                d3.selectAll("#brushHandle")
                .transition().duration(1000)
                .style("opacity", 0)

                // Expand brush
                d3.selectAll("#selectionG")
                .call(brush)
                .call(brush.move, [currentPosition[0], currentPosition[1]].map(x))

                // brush
                
                
            } 
            // Zoom out
            else {
                zoomed = false;

                // Change x-axis
                x.domain([0, 1])
                d3.selectAll("#xAxis").transition().duration(1000).call(d3.axisBottom(x))

                // Add brush handles back
                d3.selectAll("#brushHandle")
                .transition().duration(1000)
                .style("opacity", 1)

                // Shrink brush back
                d3.selectAll("#selectionG")
                .call(brush)
                .call(brush.move, [currentPosition[0], currentPosition[1]].map(x));

                brush
            }

        }






        /** Duplicate Vis **/
    //     var svg2 = d3.select('#dup')
    //     .attr("viewBox", [0, 0, width, height])

    //     svg2.append("g").call(xAxis);

    //     var clip = svg2.append("defs").append("svg:clipPath")
    //     .attr("id", "clip")
    //     .append("svg:rect")
    //     .attr("width", width )
    //     .attr("height", height )
    //     .attr("x", 0)
    //     .attr("y", 0);

    //     var brush = d3.brushX()                 // Add the brush feature using the d3.brush function
    //   .extent( [ [0,0], [width,height] ] ) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
    //   .on("end", updateChart)

    //     var scatter = svg2.append('g')
    //     .attr("clip-path", "url(#clip)")

    //     scatter
    //     .selectAll("circle")
    //     var circle2 = svg2.append("g")
    //     .attr("fill-opacity", 0.2)
    //     .selectAll("circle")
    //     .data(Float64Array.from({length: 800}, Math.random))
    //     .join("circle")
    //     .attr("transform", d => `translate(${x(d)},${y()})`)
    //     .attr("r", 3.5);

    //     scatter
    //     .append("g")
    //     .attr("class", "brush")
    //     .call(brush)
    //     .call(brush.move, [0.3, 0.5].map(x));





        //////


    </script>
</html>